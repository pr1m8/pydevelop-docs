{# CLI Documentation Macros for Jinja Templates Provides reusable macros for CLI
documentation #} {# Macro for a single CLI command with prompt #} {% macro
cli_command(cmd, prompt="$") -%} .. prompt:: bash {{ prompt }} {{ cmd }} {%-
endmacro %} {# Macro for multi-line CLI commands #} {% macro
cli_multiline(commands, prompt="$") -%} .. prompt:: bash {% for cmd in commands
%} {{ prompt }} {{ cmd }} {% endfor %} {%- endmacro %} {# Macro for CLI command
with output #} {% macro cli_with_output(cmd, output, prompt="$") -%} .. prompt::
bash {{ prompt }} {{ cmd }} .. code-block:: text {{ output }} {%- endmacro %} {#
Macro for Python REPL session #} {% macro python_repl(commands) -%} .. prompt::
python {% for cmd in commands %} >>> {{ cmd.input }} {% if cmd.output %}{{
cmd.output }}{% endif %} {% endfor %} {%- endmacro %} {# Macro for installation
instructions #} {% macro install_guide(package_name, methods) -%} Installation
------------ {% for method in methods %} **{{ method.name }}:** .. prompt:: bash
$ {{ method.command }} {% if method.note %} .. note:: {{ method.note }} {% endif
%} {% endfor %} {%- endmacro %} {# Macro for configuration examples #} {% macro
config_example(title, content, lang="yaml") -%} **{{ title }}:** .. code-block::
{{ lang }} {{ content }} {%- endmacro %} {# Macro for troubleshooting section #}
{% macro troubleshooting(issues) -%} Troubleshooting --------------- {% for
issue in issues %} **{{ issue.problem }}** {{ issue.description }} Solution: ..
prompt:: bash {{ issue.solution }} {% if issue.explanation %} {{
issue.explanation }} {% endif %} {% endfor %} {%- endmacro %} {# Macro for
automatic CLI documentation using sphinx-argparse #} {% macro auto_cli(module,
func, prog, description="") -%} .. argparse:: :module: {{ module }} :func: {{
func }} :prog: {{ prog }} {{ description }} {%- endmacro %} {# Macro for CLI
detection and documentation #} {% macro cli_detect_and_document(script_path,
description="") -%} {% set module = script_path.replace('/', '.').replace('.py',
'') %} {% set prog = script_path.split('/')[-1] %} {{ auto_cli(module,
'get_argument_parser', prog, description) }} {%- endmacro %} {# Macro for
sphinx-prompt recognition in templates #} {% macro smart_prompt(content,
detect_type=True) -%} {% if detect_type %} {% if content.startswith('$') %} ..
prompt:: bash {{ content }} {% elif content.startswith('>>>') %} .. prompt::
python {{ content }} {% elif content.startswith('#') %} .. prompt:: bash {{
content }} {% else %} .. prompt:: text {{ content }} {% endif %} {% else %} ..
prompt:: bash {{ content }} {% endif %} {%- endmacro %} {# Macro for detecting
and documenting dataclasses and Pydantic models #} {% macro
detect_model_type(obj_module, obj_name, obj_info) -%} {# Check if it's a
Pydantic model based on module path or base classes #} {% if 'pydantic' in
obj_module or 'BaseModel' in (obj_info.bases | default([])) or 'BaseSettings' in
(obj_info.bases | default([])) %} .. autopydantic_model:: {{ obj_module }}.{{
obj_name }} :members: :undoc-members: :show-inheritance:
:model-show-field-summary: :model-show-config-summary:
:model-show-validator-members: :model-show-validator-summary: :model-show-json:
:field-list-validators: :field-show-constraints: .. note:: **{{ obj_name }}** is
a Pydantic model with automatic validation and serialization. {# Check if it's a
dataclass based on decorator or fields #} {% elif obj_info.dataclass_fields or
'@dataclass' in (obj_info.decorators | default([])) %} .. autoclass:: {{
obj_module }}.{{ obj_name }} :members: :undoc-members: :show-inheritance: ..
note:: **{{ obj_name }}** is a Python dataclass with automatic field generation.
.. rubric:: Fields {% if obj_info.dataclass_fields %} {% for field_name,
field_info in obj_info.dataclass_fields.items() %} - **{{ field_name }}**: ``{{
field_info.type | default('Any') }}`` {% if field_info.default and
field_info.default != 'MISSING' %}(default: ``{{ field_info.default }}``){%
endif %} {% endfor %} {% endif %} {# Check if it's an Enum #} {% elif
'enum.Enum' in (obj_info.bases | default([])) or obj_info.obj_type == 'enum' %}
.. autoclass:: {{ obj_module }}.{{ obj_name }} :members: :undoc-members:
:show-inheritance: .. note:: **{{ obj_name }}** is an Enum defined in ``{{
obj_module }}``. {# Default class documentation #} {% else %} .. autoclass:: {{
obj_module }}.{{ obj_name }} :members: :undoc-members: :show-inheritance: {%
endif %} {%- endmacro %} {# Macro for generating enhanced model documentation
with inheritance diagrams #} {% macro document_model_with_diagram(obj_module,
obj_name, obj_info, show_diagram=True) -%} {% if show_diagram and obj_info.bases
%} .. toggle:: Show Inheritance Diagram Inheritance diagram for {{ obj_name }}:
.. graphviz:: :align: center digraph inheritance_{{ obj_name }} { node
[shape=record]; "{{ obj_name }}" [label="{{ obj_name }}"]; {% for base in
obj_info.bases %} "{{ base }}" -> "{{ obj_name }}"; {% endfor %} } {% endif %}
{{ detect_model_type(obj_module, obj_name, obj_info) }} {%- endmacro %} {# Macro
for auto-detecting and documenting API objects with appropriate formatters #} {%
macro auto_document_object(obj_module, obj_name, obj_info, context="") -%} {#
Add context information #} {% if context %} .. rubric:: {{ context }} {% endif
%} {# Route to appropriate documentation macro based on object type #} {% if
obj_info.obj_type == 'class' and (obj_info.dataclass_fields or 'pydantic' in
obj_module) %} {{ document_model_with_diagram(obj_module, obj_name, obj_info,
show_diagram=True) }} {% elif obj_info.obj_type == 'function' %} ..
autofunction:: {{ obj_module }}.{{ obj_name }} {% elif obj_info.obj_type ==
'method' %} .. automethod:: {{ obj_module }}.{{ obj_name }} {% else %} ..
autoclass:: {{ obj_module }}.{{ obj_name }} :members: :undoc-members:
:show-inheritance: {% endif %} .. autolink-examples:: {{ obj_module }}.{{
obj_name }} :collapse: {%- endmacro %} {# Macro for detecting Pydantic models
specifically #} {% macro is_pydantic_model(obj_module, obj_info) -%} {% if
'pydantic' in obj_module or 'BaseModel' in (obj_info.bases | default([])) or
'BaseSettings' in (obj_info.bases | default([])) %} True {% else %} False {%
endif %} {%- endmacro %} {# Macro for detecting dataclasses specifically #} {%
macro is_dataclass(obj_info) -%} {% if obj_info.dataclass_fields or '@dataclass'
in (obj_info.decorators | default([])) %} True {% else %} False {% endif %} {%-
endmacro %} {# Macro for smart model documentation that detects type
automatically #} {% macro smart_model_doc(obj_module, obj_name, obj_info) -%} {%
set is_pydantic = is_pydantic_model(obj_module, obj_info) == 'True' %} {% set
is_dc = is_dataclass(obj_info) == 'True' %} {% if is_pydantic %} .. admonition::
Pydantic Model :class: tip This is a Pydantic model with built-in validation and
serialization capabilities. {% elif is_dc %} .. admonition:: Dataclass :class:
note This is a Python dataclass with automatic field generation and type hints.
{% endif %} {{ detect_model_type(obj_module, obj_name, obj_info) }} {%- endmacro
%}
