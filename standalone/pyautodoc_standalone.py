#!/usr/bin/env python3
"""
PyAutoDoc Standalone - Drop-in Documentation Generator

This is a completely self-contained version of PyAutoDoc that can be dropped
into any Python project. It includes all configuration and templates inline.

Just copy this file to your project and run:
    python pyautodoc_standalone.py init
    python pyautodoc_standalone.py build
    python pyautodoc_standalone.py serve

No external dependencies needed for basic operation!
"""

import os
import sys
import shutil
import subprocess
import argparse
import json
import textwrap
import tempfile
import webbrowser
from pathlib import Path
from typing import List, Dict, Any, Optional
from dataclasses import dataclass

# Embedded minimal tomli implementation for pyproject.toml parsing
class MiniTomli:
    """Minimal TOML parser for pyproject.toml files."""
    
    @staticmethod
    def loads(s: str) -> dict:
        """Parse a TOML string (very basic implementation)."""
        result = {}
        current_section = result
        section_path = []
        
        for line in s.split('\n'):
            line = line.strip()
            
            # Skip comments and empty lines
            if not line or line.startswith('#'):
                continue
            
            # Section header
            if line.startswith('[') and line.endswith(']'):
                section = line[1:-1].strip()
                # Handle nested sections like [tool.poetry]
                parts = section.split('.')
                current_section = result
                section_path = []
                
                for part in parts:
                    if part not in current_section:
                        current_section[part] = {}
                    current_section = current_section[part]
                    section_path.append(part)
                continue
            
            # Key-value pair
            if '=' in line:
                key, value = line.split('=', 1)
                key = key.strip()
                value = value.strip()
                
                # Remove quotes
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                elif value.startswith("'") and value.endswith("'"):
                    value = value[1:-1]
                
                current_section[key] = value
        
        return result


@dataclass
class PackageInfo:
    """Information about a discovered package."""
    name: str
    path: Path
    has_setup_py: bool
    has_pyproject: bool
    has_src_layout: bool
    source_dir: Path
    version: str = "0.1.0"
    description: str = ""


class PyAutoDocStandalone:
    """Standalone documentation generator that works without any dependencies."""
    
    # Minimal Sphinx conf.py that works without external themes
    MINIMAL_CONF = '''"""
Minimal Sphinx configuration generated by PyAutoDoc.
Works without any external dependencies beyond Sphinx itself.
"""

import os
import sys
from pathlib import Path

# Add project to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))

# Add package paths
{package_paths}

# Basic project information
project = '{project_name}'
copyright = '2024, {project_name} Contributors'
author = '{project_name} Contributors'
version = '{version}'
release = version

# Minimal extensions (all built into Sphinx)
extensions = [
    'sphinx.ext.autodoc',
    'sphinx.ext.viewcode',
    'sphinx.ext.napoleon',
]

# Basic configuration
templates_path = ['_templates']
exclude_patterns = ['_build', 'Thumbs.db', '.DS_Store']
source_suffix = '.rst'
master_doc = 'index'

# HTML output with built-in theme
html_theme = 'alabaster'
html_theme_options = {{
    'description': '{project_name} Documentation',
    'fixed_sidebar': True,
}}

# Autodoc configuration
autodoc_default_options = {{
    'members': True,
    'member-order': 'bysource',
    'special-members': '__init__',
    'undoc-members': True,
    'exclude-members': '__weakref__'
}}

# Napoleon configuration
napoleon_google_docstring = True
napoleon_numpy_docstring = True
napoleon_include_init_with_doc = True
'''

    # Minimal index.rst
    MINIMAL_INDEX = '''
{title}
{title_underline}

.. toctree::
   :maxdepth: 2
   :caption: Contents:

   modules

Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
'''

    # Minimal modules.rst
    MINIMAL_MODULES = '''
API Reference
=============

.. toctree::
   :maxdepth: 4

{modules}
'''

    def __init__(self, project_root: Optional[Path] = None):
        """Initialize PyAutoDoc for a project."""
        self.project_root = Path(project_root) if project_root else Path.cwd()
        self.docs_dir = self.project_root / "docs"
        self.build_dir = self.docs_dir / "_build"
        self.packages: List[PackageInfo] = []
        self.project_name = self.project_root.name
        
    def discover_packages(self) -> List[PackageInfo]:
        """Discover all Python packages in the project."""
        packages = []
        
        # Look for common Python project patterns
        locations = [
            (self.project_root, "flat"),  # Flat layout
            (self.project_root / "src", "src"),  # Src layout
            (self.project_root / "packages", "monorepo"),  # Monorepo
            (self.project_root / "lib", "lib"),  # Lib layout
        ]
        
        for location, layout_type in locations:
            if not location.exists():
                continue
            
            # Scan for Python packages
            for item in location.iterdir():
                if item.is_dir() and not item.name.startswith('.'):
                    # Check if it's a Python package
                    if (item / "__init__.py").exists():
                        packages.append(self._create_package_info(item, layout_type))
                    # Check for namespace packages
                    elif any((item / subdir / "__init__.py").exists() 
                            for subdir in item.iterdir() if subdir.is_dir()):
                        packages.append(self._create_package_info(item, layout_type))
        
        # Check if root itself is a package
        if (self.project_root / "__init__.py").exists():
            packages.append(self._create_package_info(self.project_root, "root"))
        
        # Check for single setup.py/pyproject.toml at root
        if not packages and (self.project_root / "setup.py").exists():
            # Try to find the actual package
            for item in self.project_root.iterdir():
                if item.is_dir() and (item / "__init__.py").exists():
                    packages.append(self._create_package_info(item, "flat"))
                    break
        
        self.packages = packages
        return packages
    
    def _create_package_info(self, path: Path, layout_type: str) -> PackageInfo:
        """Create PackageInfo for a discovered package."""
        name = path.name
        version = "0.1.0"
        
        # Try to extract version
        version_file = path / "__version__.py"
        if version_file.exists():
            content = version_file.read_text()
            for line in content.split('\n'):
                if '__version__' in line and '=' in line:
                    version = line.split('=')[1].strip().strip('"\'')
                    break
        
        # Try to get info from pyproject.toml
        pyproject = self.project_root / "pyproject.toml"
        if pyproject.exists():
            try:
                data = MiniTomli.loads(pyproject.read_text())
                # Try different formats
                if 'project' in data:
                    name = data['project'].get('name', name)
                    version = data['project'].get('version', version)
                elif 'tool' in data and 'poetry' in data['tool']:
                    name = data['tool']['poetry'].get('name', name)
                    version = data['tool']['poetry'].get('version', version)
            except Exception:
                pass
        
        return PackageInfo(
            name=name,
            path=path,
            has_setup_py=(self.project_root / "setup.py").exists(),
            has_pyproject=pyproject.exists(),
            has_src_layout=layout_type == "src",
            source_dir=path.parent if layout_type != "root" else path,
            version=version
        )
    
    def init_docs(self, force: bool = False) -> bool:
        """Initialize documentation structure."""
        if self.docs_dir.exists() and not force:
            print(f"‚ùå Documentation already exists at {self.docs_dir}")
            print("   Use --force to overwrite")
            return False
        
        print("üîç Discovering Python packages...")
        packages = self.discover_packages()
        
        if not packages:
            print("‚ö†Ô∏è  No Python packages found with __init__.py")
            print("   Creating documentation for the whole project...")
            # Create a synthetic package for the whole project
            self.packages = [PackageInfo(
                name=self.project_name,
                path=self.project_root,
                has_setup_py=False,
                has_pyproject=(self.project_root / "pyproject.toml").exists(),
                has_src_layout=False,
                source_dir=self.project_root,
                version="0.1.0"
            )]
        else:
            print(f"üì¶ Found {len(packages)} package(s):")
            for pkg in packages:
                print(f"   - {pkg.name} at {pkg.path.relative_to(self.project_root)}")
        
        # Create documentation structure
        print(f"\nüìÅ Creating documentation at {self.docs_dir.relative_to(self.project_root)}/")
        self.docs_dir.mkdir(parents=True, exist_ok=True)
        
        # Create files
        self._create_conf_py()
        self._create_index_rst()
        self._create_modules_rst()
        self._create_requirements()
        self._create_make_files()
        
        print("\n‚úÖ Documentation initialized!")
        print("\nüìù Next steps:")
        print("1. Install Sphinx (if not already installed):")
        print("   pip install sphinx")
        print("2. Build the documentation:")
        print("   python pyautodoc_standalone.py build")
        print("3. View the documentation:")
        print("   python pyautodoc_standalone.py serve")
        
        return True
    
    def _create_conf_py(self):
        """Create minimal conf.py."""
        # Build package path additions
        package_paths = []
        for pkg in self.packages:
            if pkg.source_dir != self.project_root:
                package_paths.append(f"sys.path.insert(0, str(project_root / '{pkg.source_dir.relative_to(self.project_root)}'))")
        
        package_paths_str = '\n'.join(package_paths) if package_paths else "# No additional paths needed"
        
        # Get project info
        version = self.packages[0].version if self.packages else "0.1.0"
        
        content = self.MINIMAL_CONF.format(
            project_name=self.project_name,
            version=version,
            package_paths=package_paths_str
        )
        
        (self.docs_dir / "conf.py").write_text(content)
        print(f"   ‚úì Created conf.py")
    
    def _create_index_rst(self):
        """Create index.rst."""
        title = f"{self.project_name} Documentation"
        content = self.MINIMAL_INDEX.format(
            title=title,
            title_underline="=" * len(title)
        )
        
        (self.docs_dir / "index.rst").write_text(content)
        print(f"   ‚úì Created index.rst")
    
    def _create_modules_rst(self):
        """Create modules.rst with package listings."""
        modules = []
        for pkg in self.packages:
            modules.append(f"   {pkg.name}")
        
        content = self.MINIMAL_MODULES.format(
            modules='\n'.join(modules) if modules else "   modules"
        )
        
        (self.docs_dir / "modules.rst").write_text(content)
        print(f"   ‚úì Created modules.rst")
        
        # Create individual module files
        for pkg in self.packages:
            self._create_module_rst(pkg)
    
    def _create_module_rst(self, pkg: PackageInfo):
        """Create RST file for a module."""
        content = f'''
{pkg.name}
{"=" * len(pkg.name)}

.. automodule:: {pkg.name}
   :members:
   :undoc-members:
   :show-inheritance:

.. toctree::
   :maxdepth: 4

'''
        
        (self.docs_dir / f"{pkg.name}.rst").write_text(content)
        print(f"   ‚úì Created {pkg.name}.rst")
    
    def _create_requirements(self):
        """Create minimal requirements.txt."""
        content = '''# Minimal documentation requirements
sphinx>=5.0.0

# Optional but recommended
# sphinx-rtd-theme>=1.0.0
# sphinx-autodoc-typehints>=1.0.0
# myst-parser>=0.18.0
'''
        
        (self.docs_dir / "requirements.txt").write_text(content)
        print(f"   ‚úì Created requirements.txt")
    
    def _create_make_files(self):
        """Create Makefile and make.bat."""
        # Makefile
        makefile = '''# Minimal makefile for Sphinx documentation

SPHINXOPTS    ?=
SPHINXBUILD   ?= sphinx-build
SOURCEDIR     = .
BUILDDIR      = _build

help:
	@$(SPHINXBUILD) -M help "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)

.PHONY: help Makefile

%: Makefile
	@$(SPHINXBUILD) -M $@ "$(SOURCEDIR)" "$(BUILDDIR)" $(SPHINXOPTS) $(O)
'''
        
        (self.docs_dir / "Makefile").write_text(makefile)
        print(f"   ‚úì Created Makefile")
        
        # make.bat for Windows
        makebat = '''@ECHO OFF

pushd %~dp0

REM Command file for Sphinx documentation

if "%SPHINXBUILD%" == "" (
	set SPHINXBUILD=sphinx-build
)
set SOURCEDIR=.
set BUILDDIR=_build

if "%1" == "" goto help

%SPHINXBUILD% >NUL 2>NUL
if errorlevel 9009 (
	echo.
	echo.The 'sphinx-build' command was not found.
	goto end
)

%SPHINXBUILD% -M %1 %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%
goto end

:help
%SPHINXBUILD% -M help %SOURCEDIR% %BUILDDIR% %SPHINXOPTS% %O%

:end
popd
'''
        
        (self.docs_dir / "make.bat").write_text(makebat)
        print(f"   ‚úì Created make.bat")
    
    def build_docs(self, builder: str = "html") -> bool:
        """Build documentation."""
        if not self.docs_dir.exists():
            print("‚ùå No documentation found. Run 'init' first.")
            return False
        
        print(f"üî® Building {builder} documentation...")
        
        # Check if sphinx is available
        try:
            subprocess.run([sys.executable, "-m", "sphinx", "--version"], 
                         capture_output=True, check=True)
        except subprocess.CalledProcessError:
            print("‚ùå Sphinx not found. Please install it:")
            print("   pip install sphinx")
            return False
        
        # Build documentation
        build_cmd = [
            sys.executable, "-m", "sphinx",
            "-b", builder,
            str(self.docs_dir),
            str(self.build_dir / builder)
        ]
        
        try:
            result = subprocess.run(build_cmd, capture_output=True, text=True)
            
            if result.returncode == 0:
                print(f"‚úÖ Documentation built successfully!")
                print(f"   Output: {self.build_dir / builder}")
                return True
            else:
                print("‚ùå Build failed:")
                print(result.stdout)
                print(result.stderr)
                return False
                
        except Exception as e:
            print(f"‚ùå Build error: {e}")
            return False
    
    def serve_docs(self, port: int = 8000):
        """Serve documentation locally."""
        html_dir = self.build_dir / "html"
        
        if not html_dir.exists():
            print("‚ùå No HTML documentation found. Building now...")
            if not self.build_docs():
                return
        
        print(f"\nüåê Serving documentation at http://localhost:{port}")
        print("   Press Ctrl+C to stop\n")
        
        # Change to html directory
        os.chdir(html_dir)
        
        # Start server
        if sys.version_info >= (3, 0):
            from http.server import HTTPServer, SimpleHTTPRequestHandler
            
            class QuietHandler(SimpleHTTPRequestHandler):
                def log_message(self, format, *args):
                    pass  # Suppress request logs
            
            with HTTPServer(("", port), QuietHandler) as httpd:
                try:
                    webbrowser.open(f"http://localhost:{port}")
                    httpd.serve_forever()
                except KeyboardInterrupt:
                    print("\n\n‚úã Server stopped")
        else:
            # Python 2 compatibility
            import SimpleHTTPServer
            import SocketServer
            
            Handler = SimpleHTTPServer.SimpleHTTPRequestHandler
            httpd = SocketServer.TCPServer(("", port), Handler)
            
            try:
                webbrowser.open(f"http://localhost:{port}")
                httpd.serve_forever()
            except KeyboardInterrupt:
                print("\n\n‚úã Server stopped")
    
    def clean(self):
        """Clean build artifacts."""
        if self.build_dir.exists():
            print("üßπ Cleaning build directory...")
            shutil.rmtree(self.build_dir)
            print("‚úÖ Cleaned")
        else:
            print("‚ÑπÔ∏è  Nothing to clean")


def main():
    """Main entry point."""
    parser = argparse.ArgumentParser(
        description="PyAutoDoc - Zero-Config Documentation Generator",
        epilog=textwrap.dedent('''
        Examples:
          python pyautodoc_standalone.py init      # Initialize docs
          python pyautodoc_standalone.py build     # Build HTML docs
          python pyautodoc_standalone.py serve     # Serve locally
          
        This tool works with any Python project structure:
          - Single package (package/__init__.py)
          - Src layout (src/package/__init__.py)
          - Monorepo (packages/*/src/package/__init__.py)
          - Namespace packages
        '''),
        formatter_class=argparse.RawDescriptionHelpFormatter
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Init
    init_parser = subparsers.add_parser('init', help='Initialize documentation')
    init_parser.add_argument('--force', '-f', action='store_true',
                           help='Overwrite existing documentation')
    
    # Build
    build_parser = subparsers.add_parser('build', help='Build documentation')
    build_parser.add_argument('--builder', '-b', default='html',
                            help='Builder to use (default: html)')
    
    # Serve
    serve_parser = subparsers.add_parser('serve', help='Serve docs locally')
    serve_parser.add_argument('--port', '-p', type=int, default=8000,
                            help='Port to serve on (default: 8000)')
    
    # Clean
    clean_parser = subparsers.add_parser('clean', help='Clean build artifacts')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(1)
    
    # Execute
    autodoc = PyAutoDocStandalone()
    
    if args.command == 'init':
        success = autodoc.init_docs(force=args.force)
        sys.exit(0 if success else 1)
        
    elif args.command == 'build':
        success = autodoc.build_docs(builder=args.builder)
        sys.exit(0 if success else 1)
        
    elif args.command == 'serve':
        autodoc.serve_docs(port=args.port)
        
    elif args.command == 'clean':
        autodoc.clean()


if __name__ == '__main__':
    main()